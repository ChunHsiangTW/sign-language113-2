{% extends "base.html" %}  
{% block title %}æ‰‹èªç·´ç¿’{% endblock %}

{% block content %}
<div class="practice-container">
  <h1 class="practice-title">ğŸ–ï¸ æ‰‹èªç·´ç¿’ï¼ˆå³æ™‚è¾¨è­˜ç‰ˆï½œä¿®æ­£ç‰ˆï¼‰</h1>

  <div class="camera-section">
    <div class="video-box" style="position:relative;max-width:900px;aspect-ratio:16/9;background:#000;border-radius:12px;overflow:hidden;border:1px solid #203079">
      <!-- åŸå§‹é¡é ­ï¼ˆä¸é¡¯ç¤ºï¼‰ï¼Œä½¿ç”¨ Canvas ç•«ç–Šåœ– -->
      <video id="video" autoplay playsinline muted style="position:absolute;inset:0;width:100%;height:100%;opacity:0"></video>
      <canvas id="canvas" style="position:absolute;inset:0;width:100%;height:100%"></canvas>
      <div id="pill" style="position:absolute;left:12px;top:12px;background:rgba(16,24,64,.6);color:#cfe0ff;border:1px solid #2a3a7a;padding:6px 10px;border-radius:999px;font-size:12px">ç’°å¢ƒæª¢æŸ¥ä¸­â€¦</div>
    </div>

    <div class="result-box" style="margin-top:12px">
      <h2>å³æ™‚è¾¨è­˜çµæœ</h2>
      <p><strong>ä¸­æ–‡æ„æ€ï¼š</strong><span id="result-text">å°šæœªå•Ÿå‹•</span></p>
      <p><strong>FPSï¼š</strong><span id="fps">0</span></p>
      <p id="hint" style="color:#9fb0ff"></p>
    </div>
  </div>

  <div class="button-row" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
    <button onclick="location.href='{{ url_for('index') }}'">å›é¦–é </button>
    <button id="btnStart">é–‹å§‹è¾¨è­˜</button>
    <button id="btnStop" disabled>åœæ­¢</button>
  </div>
</div>

<!-- ======== MediaPipe Hands ======== -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
// ===== DOM =====
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('btnStart');
const stopBtn = document.getElementById('btnStop');
const resultText = document.getElementById('result-text');
const fpsEl = document.getElementById('fps');
const hintEl = document.getElementById('hint');
const pill = document.getElementById('pill');

// ===== State =====
let stream = null;
let running = false;
let rafId = null;
let lastTime = performance.now();
const voteBuf = [];
const VOTE_K = 7;

// ===== Hands =====
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.5
});
hands.onResults(onResults);

// ===== Env pill =====
const isLocalhost = ['localhost','127.0.0.1','[::1]'].includes(location.hostname);
const isSecure = window.isSecureContext || location.protocol === 'https:';
function updateEnvPill(){
  if (isSecure){ pill.textContent = 'HTTPSï¼šå¯ä½¿ç”¨ç›¸æ©Ÿ'; }
  else if (isLocalhost){ pill.textContent = 'localhostï¼šå¯ä½¿ç”¨ç›¸æ©Ÿ'; }
  else { pill.textContent = 'éå®‰å…¨ä¾†æºï¼šå¯èƒ½ç„¡æ³•ä½¿ç”¨ç›¸æ©Ÿ'; }
}
updateEnvPill();

// ===== Camera opening with lower resolution =====
async function pickPreferredConstraint(){
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cameras = devices.filter(d => d.kind === 'videoinput');
  const external = cameras.find(c => /usb|external|pro|logi|hd|webcam/i.test(c.label));
  const first = cameras[0];

  // é™ä½è§£æåº¦
  const wh = { width: { ideal: 640 }, height: { ideal: 480 } };

  if (external) return { video: { ...wh, deviceId: { exact: external.deviceId } }, audio: false };
  if (first) return { video: { ...wh, deviceId: { exact: first.deviceId } }, audio: false };
  return { video: { ...wh, facingMode: { ideal: 'user' } }, audio: false };
}

async function openCamera(){
  const constraint = await pickPreferredConstraint();
  return await navigator.mediaDevices.getUserMedia(constraint);
}

// ===== Friendly error messages =====
function mapGumError(e){
  switch(e?.name){
    case 'NotAllowedError':
    case 'SecurityError': return 'æ¬Šé™è¢«æ‹’ï¼šè«‹å…è¨±ç›¸æ©Ÿä½¿ç”¨æˆ–æ”¹ç”¨ HTTPS / localhostã€‚';
    case 'NotReadableError':
    case 'TrackStartError': return 'ç›¸æ©Ÿè¢«å ç”¨ï¼šè«‹é—œé–‰å…¶ä»–ä½¿ç”¨ç›¸æ©Ÿçš„ç¨‹å¼ã€‚';
    case 'NotFoundError':
    case 'DevicesNotFoundError': return 'æ‰¾ä¸åˆ°ç›¸æ©Ÿï¼Œè«‹ç¢ºèªè£ç½®å­˜åœ¨ã€‚';
    case 'OverconstrainedError': return 'ç›¸æ©Ÿé™åˆ¶ç„¡æ³•æ»¿è¶³ï¼Œè«‹é™è§£æåº¦æˆ–æ›é¡é ­ã€‚';
    default: return 'é–‹å•Ÿç›¸æ©Ÿå¤±æ•—ï¼š' + (e?.message || e?.name || 'æœªçŸ¥éŒ¯èª¤');
  }
}

// ===== Start / Stop =====
startBtn.onclick = async () => {
  if (running) return;
  try {
    stream = await openCamera();
    video.srcObject = stream;
    await video.play();
    running = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    resultText.textContent = 'åµæ¸¬ä¸­â€¦';
    hintEl.textContent = '';
    lastTime = performance.now();
    loop();
  } catch (err) {
    const msg = mapGumError(err);
    resultText.textContent = msg;
    hintEl.textContent = 'è‹¥é é¢åµŒåœ¨ iFrameï¼Œéœ€å…è¨± cameraï¼›æˆ–é»å³ä¸Šè§’åœ¨æ–°åˆ†é é–‹å•Ÿã€‚';
    alert(msg);
  }
};

stopBtn.onclick = () => {
  running = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  if (rafId) cancelAnimationFrame(rafId);
  if (stream) stream.getTracks().forEach(t => t.stop());
  stream = null;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  resultText.textContent = 'å·²åœæ­¢';
};

// ===== Main loop =====
async function loop(){
  if (!running) return;
  if (video.readyState < 2){ rafId = requestAnimationFrame(loop); return; }
  try { await hands.send({ image: video }); } catch(e){ console.warn(e); }
  const now = performance.now();
  fpsEl.textContent = Math.max(1, Math.round(1000 / Math.max(1, (now - lastTime))));
  lastTime = now;
  rafId = requestAnimationFrame(loop);
}

// ===== onResults =====
function onResults(results){
  const w = video.videoWidth || canvas.clientWidth;
  const h = video.videoHeight || canvas.clientHeight;
  if (w && h){ canvas.width = w; canvas.height = h; }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

  if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
    for (const landmarks of results.multiHandLandmarks) {
      drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { lineWidth: 3 });
      drawLandmarks(ctx, landmarks, { lineWidth: 2 });
    }
    const word = classifyGesture(results.multiHandLandmarks[0]);
    pushVote(word);
    resultText.textContent = majorityVote(voteBuf);
  } else {
    resultText.textContent = 'æœªåµæ¸¬åˆ°æ‰‹éƒ¨';
  }
}

// ===== Voting =====
function pushVote(w){ voteBuf.push(w); if (voteBuf.length > VOTE_K) voteBuf.shift(); }
function majorityVote(arr){
  const m = new Map();
  for (const v of arr) m.set(v, (m.get(v)||0)+1);
  let best = 'ï¼ˆç„¡è³‡æ–™ï¼‰', c = 0; m.forEach((n,k)=>{ if (n>c){ best=k; c=n; } });
  return best;
}

// ===== Gesture rules =====
function classifyGesture(pts){
  const isFingerUp = (tip, pip) => pts[tip].y < pts[pip].y;
  const thumbUp = () => { const tip=pts[4], base=pts[2]; const dx=tip.x-base.x, dy=tip.y-base.y; return Math.hypot(dx,dy)>0.08 };
  const fingers = [
    isFingerUp(8,6),
    isFingerUp(12,10),
    isFingerUp(16,14),
    isFingerUp(20,18)
  ];
  const upCount = fingers.filter(Boolean).length;
  if (upCount === 0) return 'ä½ å¥½';
  if (upCount === 2 && fingers[0] && fingers[1]) return 'å†è¦‹';
  if (upCount === 4) return 'è¬è¬';
  if (thumbUp() && upCount===0) return 'å¥½çš„';
  return 'åµæ¸¬ä¸­â€¦';
}
</script>
{% endblock %}
